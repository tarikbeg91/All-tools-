<!DOCTYPE html>
<html lang="hi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‡§µ‡§ø‡§ú‡§º‡•Å‡§Ö‡§≤ ‡§∂‡•Ä‡§ü ‡§≤‡•á‡§Ü‡§â‡§ü ‡§ï‡•à‡§≤‡§ï‡•Å‡§≤‡•á‡§ü‡§∞ (W√óL)</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0; padding: 0; background-color: #f0f4f8; 
            color: #333; display: flex; flex-direction: column; align-items: center;
        }
        .app-header {
            background-color: #34495e; color: white; padding: 10px 20px;
            display: flex; justify-content: space-between; align-items: center;
            width: 100%; box-sizing: border-box; position: fixed; 
            top: 0; left: 0; z-index: 1001; 
        }
        .app-header .title { font-size: 1.3em; font-weight: bold; }
        .header-icons { display: flex; gap: 10px; }
        .header-icons button {
            background: none; border: none; color: white; font-size: 1.4em; 
            cursor: pointer; padding: 8px; border-radius: 4px; transition: background-color 0.2s;
            display: flex; align-items: center; justify-content: center;
        }
        .header-icons button:hover { background-color: rgba(255,255,255,0.15); }
        .container { 
            margin-top: 60px; 
            background-color: #fff; padding: 20px; border-radius: 10px; 
            box-shadow: 0 6px 20px rgba(0,0,0,0.1); width: 95%; max-width: 1000px;
        }
        h2 { text-align: center; color: #2c3e50; margin-bottom: 20px; }
        .input-group, .parts-group, .results-group { 
            margin-bottom: 25px; padding: 20px; border: 1px solid #dce4ec; 
            border-radius: 8px; background-color: #fafdff;
        }
        label { display: block; margin-bottom: 8px; font-weight: 600; color: #4a5568; }
        input[type="number"], input[type="text"] {
            width: calc(100% - 22px); padding: 10px; margin-bottom: 15px;
            border: 1px solid #cbd5e0; border-radius: 5px; box-sizing: border-box; font-size: 1em;
        }
        input[type="checkbox"] { margin-right: 5px; vertical-align: middle;}
        input:focus { border-color: #4299e1; box-shadow: 0 0 0 1px #4299e1; outline: none; }
        button, .button-like-label {
            background-color: #3498db; color: white; padding: 10px 18px; border: none;
            border-radius: 5px; cursor: pointer; font-size: 1em; transition: background-color 0.2s;
            margin-right: 10px; margin-top: 5px; 
            display: inline-block; text-align: center;
        }
        button:hover, .button-like-label:hover { background-color: #2980b9; }
        #exportJsonButton { background-color: #16a085;} #exportJsonButton:hover { background-color: #117a65;}
        .button-like-label { background-color: #f39c12; } .button-like-label:hover { background-color: #e67e22; }
        #showHistoryButton { background-color: #8e44ad;} #showHistoryButton:hover { background-color: #7d3c98;}
        #clearSavedDataButton { background-color: #c0392b;} #clearSavedDataButton:hover { background-color: #a93226;}
        #resetButton { background-color: #d35400; } #resetButton:hover { background-color: #b84300; }
        .delete-btn { background-color: #e74c3c; padding: 5px 10px; font-size: 0.9em; }
        .delete-btn:hover { background-color: #c0392b; }
        table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        th, td { border: 1px solid #e2e8f0; padding: 10px; text-align: left; }
        th { background-color: #edf2f7; font-weight: 600; }
        .sheets-container { display: flex; flex-wrap: wrap; gap: 20px; margin-top: 20px; justify-content: center;}
        .sheet-wrapper { border: 1px solid #bdc3c7; padding: 10px; background-color: #ecf0f1; border-radius: 5px; }
        .sheet-wrapper h3 { margin-top: 0; text-align: center; color: #34495e; font-size: 1.1em; }
        canvas { border: 1px solid #7f8c8d; background-color: white; }
        .results-summary { font-size: 1.2em; font-weight: bold; text-align: center; margin-bottom: 15px;}
        .actions-div button, .actions-div .button-like-label { margin-bottom: 10px;}
        .modal {
            display: none; position: fixed; z-index: 1000; left: 0; top: 0;
            width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5);
            align-items: center; justify-content: center;
        }
        .modal-content, .sheet-size-modal-content {
            background-color: #fefefe; margin: auto; padding: 20px; border: 1px solid #888; 
            width: 90%; max-width: 500px; border-radius: 8px; position: relative; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .sheet-size-modal-content { max-width: 400px; }
         .sheet-size-modal-content h2, .modal-content h2 { margin-top: 0;}
        .close-button {
            color: #aaa; position: absolute; top: 10px; right: 15px;
            font-size: 28px; font-weight: bold;
        }
        .close-button:hover, .close-button:focus { color: black; text-decoration: none; cursor: pointer; }
        #historyList {
            list-style-type: none; padding: 0; max-height: 300px; overflow-y: auto;
            border-top: 1px solid #eee; margin-top: 15px;
        }
        #historyList li {
            padding: 10px; border-bottom: 1px solid #eee; cursor: pointer;
            font-size: 0.9em; display: flex; justify-content: space-between; align-items: center;
        }
        #historyList li:hover { background-color: #f0f0f0; }
        #historyList li small { color: #777; margin-left: 10px;}
        #jsonMenu {
            display:none; position:absolute; right:5px; top: 45px; 
            background-color:white; border:1px solid #ccc; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); z-index:1002; 
            border-radius:4px; min-width:180px;
        }
        #jsonMenu a, #jsonMenu label.json-menu-item {
            display: block; padding: 10px 15px; text-decoration: none;
            color: #333; cursor: pointer; font-size: 0.95em;
        }
        #jsonMenu a:hover, #jsonMenu label.json-menu-item:hover { background-color: #f0f0f0; }

        @media print {
            body { margin: 0; padding: 10px; font-size: 10pt; }
            .app-header, .parts-group, 
            .actions-div button, /* ‡§ï‡•á‡§µ‡§≤ ‡§ï‡•à‡§≤‡§ï‡•Å‡§≤‡•á‡§ü ‡§î‡§∞ ‡§∞‡•Ä‡§∏‡•á‡§ü ‡§¨‡§ü‡§® ‡§™‡•ç‡§∞‡§ø‡§Ç‡§ü ‡§Æ‡•á‡§Ç ‡§õ‡§ø‡§™‡•á‡§Ç‡§ó‡•á */
            .actions-div .button-like-label, /* JSON ‡§á‡§Æ‡•ç‡§™‡•ã‡§∞‡•ç‡§ü ‡§≤‡•á‡§¨‡§≤ ‡§õ‡§ø‡§™‡§æ‡§è‡§Ç */
            .actions-div #exportJsonButton, /* JSON ‡§è‡§ï‡•ç‡§∏‡§™‡•ã‡§∞‡•ç‡§ü ‡§¨‡§ü‡§® ‡§õ‡§ø‡§™‡§æ‡§è‡§Ç */
            .actions-div #showHistoryButton, /* ‡§π‡§ø‡§∏‡•ç‡§ü‡•ç‡§∞‡•Ä ‡§¨‡§ü‡§® ‡§õ‡§ø‡§™‡§æ‡§è‡§Ç */
            .actions-div #clearSavedDataButton, /* ‡§ï‡•ç‡§≤‡§ø‡§Ø‡§∞ ‡§°‡•á‡§ü‡§æ ‡§¨‡§ü‡§® ‡§õ‡§ø‡§™‡§æ‡§è‡§Ç */
            .modal, #jsonMenu, 
            #addedPiecesSection .no-print 
             { display: none !important; }
            .container { margin-top: 0; box-shadow: none; border: none; width: 100%; max-width: 100%; padding: 0;}
            .results-group h2, .results-summary { text-align: left; margin-bottom: 5px; page-break-before: auto; page-break-after: avoid;}
            .input-group#addedPiecesSection { display: block !important; border: none; padding: 0; margin-bottom: 15px;} 
            .input-group#addedPiecesSection h2 { display: block !important; text-align: left; margin-bottom: 5px; font-size: 12pt;}
            table { margin-top: 5px; }
            table th, table td { font-size: 9pt; padding: 4px; border: 1px solid #ccc !important;}
            .sheets-container { display: block; margin-top: 10px; gap: 0; }
            .sheet-wrapper {
                border: 1px solid #ccc; padding: 5px; margin-bottom: 15px; 
                page-break-inside: avoid; width: 100% !important; box-sizing: border-box;
            }
            .sheet-wrapper h3 { font-size: 1.1em; margin-bottom: 5px; }
            canvas { max-width: 100% !important; height: auto !important; border: 1px solid #aaa; }
        }
    </style>
</head>
<body>
    <header class="app-header">
        <div class="title">‡§∂‡•Ä‡§ü ‡§≤‡•á‡§Ü‡§â‡§ü</div>
        <div class="header-icons">
            <button id="printPdfIcon" title="‡§™‡•ç‡§∞‡§ø‡§Ç‡§ü/PDF ‡§¨‡§®‡§æ‡§è‡§Ç" onclick="prepareForPrint()">üìÑ</button>
            <button id="sheetSettingsIcon" title="‡§∂‡•Ä‡§ü ‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§∏" onclick="showSheetSettingsModal()">‚öôÔ∏è</button> 
            <button id="historyIcon" title="‡§π‡§ø‡§∏‡•ç‡§ü‡•ç‡§∞‡•Ä" onclick="showHistoryModal()">üìú</button>
            <button id="jsonIcon" title="JSON ‡§ë‡§™‡§∞‡•á‡§∂‡§®‡•ç‡§∏" onclick="toggleJsonMenu(event)">üíæ</button>
        </div>
    </header>
    <div id="jsonMenu"> 
        <a href="#" onclick="exportDataAsJson(); closeJsonMenu();">JSON ‡§è‡§ï‡•ç‡§∏‡§™‡•ã‡§∞‡•ç‡§ü ‡§ï‡§∞‡•á‡§Ç</a>
        <label for="importJsonInputHidden" class="json-menu-item">JSON ‡§á‡§Æ‡•ç‡§™‡•ã‡§∞‡•ç‡§ü ‡§ï‡§∞‡•á‡§Ç</label>
        <input type="file" id="importJsonInputHidden" accept=".json" style="display: none;" onchange="importDataFromJson(event); closeJsonMenu();">
        <a href="#" onclick="clearSavedData(); closeJsonMenu();">‡§∏‡•á‡§µ ‡§°‡•á‡§ü‡§æ ‡§ï‡•ç‡§≤‡§ø‡§Ø‡§∞ ‡§ï‡§∞‡•á‡§Ç</a>
    </div>

    <div class="container">
        <div class="parts-group">
            <h2>‡§™‡•Ä‡§∏ ‡§ú‡•ã‡§°‡§º‡•á‡§Ç</h2>
            <label for="partName">‡§™‡•Ä‡§∏ ‡§ï‡§æ ‡§®‡§æ‡§Æ (‡§µ‡•à‡§ï‡§≤‡•ç‡§™‡§ø‡§ï):</label>
            <input type="text" id="partName" placeholder="‡§™‡•Ä‡§∏ 1">
            <label for="partWidth">‡§™‡•Ä‡§∏ ‡§ï‡•Ä ‡§ö‡•å‡§°‡§º‡§æ‡§à (cm):</label>
            <input type="number" id="partWidth" placeholder="cm">
            <label for="partLength">‡§™‡•Ä‡§∏ ‡§ï‡•Ä ‡§≤‡§Ç‡§¨‡§æ‡§à (‡§ó‡•ç‡§∞‡•á‡§® ‡§ï‡•Ä ‡§¶‡§ø‡§∂‡§æ ‡§Æ‡•á‡§Ç) (cm):</label>
            <input type="number" id="partLength" placeholder="cm">
            <label for="partQuantity">‡§ï‡§ø‡§§‡§®‡•á ‡§™‡•Ä‡§∏:</label>
            <input type="number" id="partQuantity" min="1" placeholder="1">
            <button onclick="addPiece()">‡§™‡•Ä‡§∏ ‡§ú‡•ã‡§°‡§º‡•á‡§Ç</button>
        </div>

        <div class="input-group" id="addedPiecesSection"> 
            <h2>‡§ú‡•ã‡§°‡§º‡•á ‡§ó‡§è ‡§™‡•Ä‡§∏</h2>
            <table id="piecesTable">
                <thead>
                    <tr><th>‡§®‡§æ‡§Æ</th><th>‡§ö‡•å‡§°‡§º‡§æ‡§à (cm)</th><th>‡§≤‡§Ç‡§¨‡§æ‡§à (cm)</th><th>‡§∏‡§Ç‡§ñ‡•ç‡§Ø‡§æ</th><th class="no-print">‡§π‡§ü‡§æ‡§è‡§Ç</th></tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
        <div class="actions-div">
            <button onclick="calculateAndDrawLayout()">‡§≤‡•á‡§Ü‡§â‡§ü ‡§ï‡•Ä ‡§ó‡§£‡§®‡§æ ‡§ï‡§∞‡•á‡§Ç ‡§î‡§∞ ‡§¶‡§ø‡§ñ‡§æ‡§è‡§Ç</button>
            <button id="resetButton" onclick="resetAll()">‡§∞‡•Ä‡§∏‡•á‡§ü (‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§®)</button> 
        </div>

        <div class="results-group">
            <h2>‡§™‡§∞‡§ø‡§£‡§æ‡§Æ</h2>
            <div class="results-summary" id="resultsSummary">‡§ï‡•Å‡§≤ ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï ‡§∂‡•Ä‡§ü‡•ç‡§∏: 0</div>
            <div class="sheets-container" id="sheetsContainer"></div>
        </div>
    </div>

    <div id="sheetSettingsModal" class="modal">
        <div class="sheet-size-modal-content">
            <span class="close-button" onclick="closeSheetSettingsModal()">&times;</span>
            <h2>‡§∂‡•Ä‡§ü ‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§∏ (cm ‡§Æ‡•á‡§Ç)</h2>
            <label for="modalSheetLength">‡§∂‡•Ä‡§ü ‡§ï‡•Ä ‡§≤‡§Ç‡§¨‡§æ‡§à (‡§ó‡•ç‡§∞‡•á‡§®):</label>
            <input type="number" id="modalSheetLength" value="244">
            <label for="modalSheetWidth">‡§∂‡•Ä‡§ü ‡§ï‡•Ä ‡§ö‡•å‡§°‡§º‡§æ‡§à:</label>
            <input type="number" id="modalSheetWidth" value="122">
            <div>
                <input type="checkbox" id="modalHasGrainDirection" checked>
                <label for="modalHasGrainDirection" style="display: inline-block; margin-bottom: 0; font-weight:normal;">‡§ó‡•ç‡§∞‡•á‡§® ‡§ï‡•Ä ‡§¶‡§ø‡§∂‡§æ ‡§ï‡§æ ‡§ß‡•ç‡§Ø‡§æ‡§® ‡§∞‡§ñ‡•á‡§Ç</label>
            </div>
            <button onclick="applySheetSettings()" style="margin-top: 15px; width:100%;">‡§≤‡§æ‡§ó‡•Ç ‡§ï‡§∞‡•á‡§Ç ‡§î‡§∞ ‡§∏‡•á‡§µ ‡§ï‡§∞‡•á‡§Ç</button>
        </div>
    </div>

    <div id="historyModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeHistoryModal()">&times;</span>
            <h2>‡§π‡§ø‡§∏‡•ç‡§ü‡•ç‡§∞‡•Ä</h2>
            <ul id="historyList"></ul>
            <p><small>‡§®‡•ã‡§ü: ‡§Ø‡§π ‡§ï‡•á‡§µ‡§≤ ‡§™‡§ø‡§õ‡§≤‡•á ‡§ï‡•Å‡§õ ‡§¨‡§¶‡§≤‡§æ‡§µ‡•ã‡§Ç ‡§ï‡•ã ‡§¶‡§ø‡§ñ‡§æ‡§§‡§æ ‡§π‡•à‡•§ ‡§ï‡§ø‡§∏‡•Ä ‡§Ü‡§á‡§ü‡§Æ ‡§™‡§∞ ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡§ï‡•á ‡§â‡§∏‡•á ‡§≤‡•ã‡§° ‡§ï‡§∞‡•á‡§Ç‡•§</small></p>
        </div>
    </div>
    
    <script>
        let pieces = [];
        let pieceIdCounter = 0; 
        const BASE_CANVAS_SCALE = 2.5; 
        const MIN_TEXT_PIECE_WIDTH_LOGICAL_INSIDE = 25 * BASE_CANVAS_SCALE * 0.35; 
        const MIN_TEXT_PIECE_HEIGHT_LOGICAL_INSIDE = 12 * BASE_CANVAS_SCALE * 0.35;
        const MIN_TEXT_FREE_WIDTH_LOGICAL = 20 * BASE_CANVAS_SCALE * 0.35; 
        const MIN_TEXT_FREE_HEIGHT_LOGICAL = 10 * BASE_CANVAS_SCALE * 0.35;
        const KERF_WIDTH_CM = 0.3; 

        const modalSheetLengthEl = document.getElementById('modalSheetLength');
        const modalSheetWidthEl = document.getElementById('modalSheetWidth');
        const modalSheetHasGrainEl = document.getElementById('modalHasGrainDirection');
        const sheetSettingsModalEl = document.getElementById('sheetSettingsModal');
        const partNameEl = document.getElementById('partName');
        const partLengthEl = document.getElementById('partLength');
        const partWidthEl = document.getElementById('partWidth');
        const partQuantityEl = document.getElementById('partQuantity');
        const piecesTableBodyEl = document.querySelector('#piecesTable tbody');
        const resultsSummaryEl = document.getElementById('resultsSummary');
        const sheetsContainerEl = document.getElementById('sheetsContainer');
        const historyModalEl = document.getElementById('historyModal');
        const historyListEl = document.getElementById('historyList');
        const jsonMenuEl = document.getElementById('jsonMenu');

        const STORAGE_KEY_PIECES = 'sheetLayoutCalculatorPieces_v7'; 
        const STORAGE_KEY_SETTINGS = 'sheetLayoutCalculatorSettings_v7';
        const STORAGE_KEY_ID_COUNTER = 'sheetLayoutCalculatorIdCounter_v7';
        const STORAGE_KEY_HISTORY = 'sheetLayoutCalculatorHistory_v7';
        const MAX_HISTORY_STATES = 20; 
        let historyStack = [];

        function showSheetSettingsModal() { const settingsStr = localStorage.getItem(STORAGE_KEY_SETTINGS); if (settingsStr) { const settings = JSON.parse(settingsStr); modalSheetLengthEl.value = settings.sheetLength || "244"; modalSheetWidthEl.value = settings.sheetWidth || "122"; modalSheetHasGrainEl.checked = typeof settings.hasGrain === 'boolean' ? settings.hasGrain : true; } else { modalSheetLengthEl.value = "244"; modalSheetWidthEl.value = "122"; modalSheetHasGrainEl.checked = true; } sheetSettingsModalEl.style.display = 'flex'; }
        function closeSheetSettingsModal() { sheetSettingsModalEl.style.display = 'none'; }
        function applySheetSettings() { autoSaveData(); saveStateToHistory(); closeSheetSettingsModal(); if (pieces.length > 0) { resultsSummaryEl.textContent = `‡§∂‡•Ä‡§ü ‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§Ö‡§™‡§°‡•á‡§ü ‡§ï‡•Ä ‡§ó‡§à‡§Ç‡•§`; sheetsContainerEl.innerHTML = '<p style="text-align:center; color: #555;">‡§®‡§Ø‡§æ ‡§≤‡•á‡§Ü‡§â‡§ü ‡§¶‡•á‡§ñ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§</p>'; } }
        function toggleJsonMenu(event) { event.stopPropagation(); jsonMenuEl.style.display = jsonMenuEl.style.display === 'block' ? 'none' : 'block'; }
        function closeJsonMenu() { jsonMenuEl.style.display = 'none'; }
        document.body.addEventListener('click', function(event) { if (jsonMenuEl.style.display === 'block' && !jsonMenuEl.contains(event.target) && event.target.id !== 'jsonIcon') closeJsonMenu(); });
        
        function addPiece() { 
            const name = partNameEl.value.trim() || `‡§™‡•Ä‡§∏-${pieceIdCounter + 1}`;
            const pieceW = parseFloat(partWidthEl.value); // ‡§ö‡•å‡§°‡§º‡§æ‡§à ‡§™‡§π‡§≤‡•á
            const pieceL = parseFloat(partLengthEl.value); // ‡§≤‡§Ç‡§¨‡§æ‡§à (‡§ó‡•ç‡§∞‡•á‡§®) ‡§¨‡§æ‡§¶ ‡§Æ‡•á‡§Ç
            const quantity = parseInt(partQuantityEl.value) || 1; 
            if (isNaN(pieceL) || pieceL <= 0 || isNaN(pieceW) || pieceW <= 0 || isNaN(quantity) || quantity <= 0) {
                alert("‡§ï‡•É‡§™‡§Ø‡§æ ‡§∏‡§≠‡•Ä ‡§™‡•Ä‡§∏ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡§æ‡§®‡•ç‡§Ø ‡§∏‡§ï‡§æ‡§∞‡§æ‡§§‡•ç‡§Æ‡§ï ‡§∏‡§Ç‡§ñ‡•ç‡§Ø‡§æ‡§è‡§Å ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç‡•§"); return;
            }
            const sheetL_cm_val = parseFloat(modalSheetLengthEl.value); 
            const sheetW_cm_val = parseFloat(modalSheetWidthEl.value);
            const hasGrain = modalSheetHasGrainEl.checked; let canFit = false;
            if (hasGrain) { if (pieceL <= sheetL_cm_val && pieceW <= sheetW_cm_val) canFit = true; }
            else { if ((pieceL <= sheetL_cm_val && pieceW <= sheetW_cm_val) || (pieceW <= sheetL_cm_val && pieceL <= sheetW_cm_val)) canFit = true; }
            if (!canFit) { alert(`‡§™‡•Ä‡§∏ "${name}" (${pieceW}√ó${pieceL}) ‡§∂‡•Ä‡§ü (${sheetW_cm_val}√ó${sheetL_cm_val}) ‡§™‡§∞ ${hasGrain ? '‡§ó‡•ç‡§∞‡•á‡§®...' : ''} ‡§´‡§ø‡§ü ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã ‡§∏‡§ï‡§§‡§æ‡•§`); return; }
            pieces.push({id: pieceIdCounter, name, length: pieceL, width: pieceW, quantity, area: pieceL * pieceW});
            pieceIdCounter++; renderPiecesTable(); clearPieceInputs(); autoSaveData(); saveStateToHistory();
        }
        function clearPieceInputs() { 
            partNameEl.value = `‡§™‡•Ä‡§∏-${pieceIdCounter + 1}`; 
            partWidthEl.value = ''; // ‡§ö‡•å‡§°‡§º‡§æ‡§à ‡§µ‡§æ‡§≤‡§æ ‡§´‡§º‡•Ä‡§≤‡•ç‡§° ‡§™‡§π‡§≤‡•á
            partLengthEl.value = ''; 
            partQuantityEl.value = ''; 
            partWidthEl.focus(); // ‡§ï‡§∞‡•ç‡§∏‡§∞ ‡§Ö‡§¨ ‡§ö‡•å‡§°‡§º‡§æ‡§à ‡§µ‡§æ‡§≤‡•á ‡§á‡§®‡§™‡•Å‡§ü ‡§™‡§∞ ‡§ú‡§æ‡§è‡§ó‡§æ
        }
        function renderPiecesTable() { 
            piecesTableBodyEl.innerHTML = '';
            pieces.forEach((p, index) => {
                const row = piecesTableBodyEl.insertRow();
                row.insertCell().textContent = p.name; 
                row.insertCell().textContent = p.width;  // ‡§ö‡•å‡§°‡§º‡§æ‡§à ‡§™‡§π‡§≤‡•á
                row.insertCell().textContent = p.length; // ‡§≤‡§Ç‡§¨‡§æ‡§à ‡§¨‡§æ‡§¶ ‡§Æ‡•á‡§Ç
                row.insertCell().textContent = p.quantity;
                const btn = document.createElement('button'); btn.textContent = 'X'; btn.className = 'delete-btn no-print'; // no-print ‡§ï‡•ç‡§≤‡§æ‡§∏ ‡§ú‡•ã‡§°‡§º‡•Ä
                btn.onclick = () => removePiece(index);
                const cell = row.insertCell(); cell.className = 'no-print'; cell.appendChild(btn); cell.style.textAlign = 'center';
            });
        }
        function removePiece(index) { pieces.splice(index, 1); renderPiecesTable(); autoSaveData(); saveStateToHistory(); }
        
        modalSheetLengthEl.addEventListener('change', () => { autoSaveData(); saveStateToHistory(); });
        modalSheetWidthEl.addEventListener('change', () => { autoSaveData(); saveStateToHistory(); });
        modalSheetHasGrainEl.addEventListener('change', () => { autoSaveData(); saveStateToHistory(); });

        function resetAll() { if (confirm("‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§µ‡§æ‡§ï‡§à ‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§°‡•á‡§ü‡§æ ‡§î‡§∞ ‡§≤‡•á‡§Ü‡§â‡§ü ‡§∞‡•Ä‡§∏‡•á‡§ü ‡§ï‡§∞‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?")) resetAllInternal(true); }
        function resetAllInternal(saveToHist = false) {  pieces = []; pieceIdCounter = 0; modalSheetLengthEl.value = "244"; modalSheetWidthEl.value = "122"; modalSheetHasGrainEl.checked = true; renderPiecesTable(); clearPieceInputs(); resultsSummaryEl.textContent = '‡§ï‡•Å‡§≤ ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï ‡§∂‡•Ä‡§ü‡•ç‡§∏: 0'; sheetsContainerEl.innerHTML = ''; autoSaveData(); if (saveToHist) saveStateToHistory(); }
        function autoSaveData() { try { localStorage.setItem(STORAGE_KEY_PIECES, JSON.stringify(pieces)); const settings = { sheetLength: modalSheetLengthEl.value, sheetWidth: modalSheetWidthEl.value, hasGrain: modalSheetHasGrainEl.checked }; localStorage.setItem(STORAGE_KEY_SETTINGS, JSON.stringify(settings)); localStorage.setItem(STORAGE_KEY_ID_COUNTER, pieceIdCounter.toString()); } catch (e) { console.error("‡§°‡•á‡§ü‡§æ ‡§ë‡§ü‡•ã-‡§∏‡•á‡§µ ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø:", e); } }
        function exportDataAsJson() {  if (pieces.length === 0 && !modalSheetLengthEl.value && !modalSheetWidthEl.value) { alert("‡§è‡§ï‡•ç‡§∏‡§™‡•ã‡§∞‡•ç‡§ü ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡•ã‡§à ‡§°‡•á‡§ü‡§æ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡•§"); return; } const dataToExport = { pieces: pieces, settings: { sheetLength: modalSheetLengthEl.value, sheetWidth: modalSheetWidthEl.value, hasGrain: modalSheetHasGrainEl.checked }, pieceIdCounter: pieceIdCounter }; const dataStr = JSON.stringify(dataToExport, null, 2); const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr); const exportFileDefaultName = 'sheet_layout_data.json'; let linkElement = document.createElement('a'); linkElement.setAttribute('href', dataUri); linkElement.setAttribute('download', exportFileDefaultName); linkElement.click(); linkElement.remove(); }
        function importDataFromJson(event) {  const file = event.target.files[0]; if (!file) return; if (file.type !== "application/json") { alert("‡§ï‡•É‡§™‡§Ø‡§æ ‡§è‡§ï ‡§Æ‡§æ‡§®‡•ç‡§Ø JSON ‡§´‡§º‡§æ‡§á‡§≤ ‡§ö‡•Å‡§®‡•á‡§Ç‡•§"); event.target.value = null; return; } const reader = new FileReader(); reader.onload = function(e) { try { const importedData = JSON.parse(e.target.result); if (importedData && importedData.pieces && importedData.settings) { pieces = importedData.pieces || []; const settings = importedData.settings; modalSheetLengthEl.value = settings.sheetLength || "244"; modalSheetWidthEl.value = settings.sheetWidth || "122"; modalSheetHasGrainEl.checked = typeof settings.hasGrain === 'boolean' ? settings.hasGrain : true; pieceIdCounter = parseInt(importedData.pieceIdCounter) || 0; if (pieces.length > 0 && pieceIdCounter === 0) { const maxId = pieces.reduce((max, p) => (typeof p.id === 'number' && p.id > max ? p.id : max), -1); pieceIdCounter = maxId >= 0 ? maxId + 1 : pieces.length; } renderPiecesTable(); clearPieceInputs(); autoSaveData(); saveStateToHistory(); resultsSummaryEl.textContent = '‡§ï‡•Å‡§≤ ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï ‡§∂‡•Ä‡§ü‡•ç‡§∏: 0'; sheetsContainerEl.innerHTML = '<p style="text-align:center; color: #555;">‡§≤‡•á‡§Ü‡§â‡§ü ‡§¶‡•á‡§ñ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§</p>'; alert("‡§°‡•á‡§ü‡§æ JSON ‡§´‡§º‡§æ‡§á‡§≤ ‡§∏‡•á ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§á‡§Æ‡•ç‡§™‡•ã‡§∞‡•ç‡§ü ‡§ï‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ!"); } else { alert("JSON ‡§´‡§º‡§æ‡§á‡§≤ ‡§ï‡§æ ‡§™‡•ç‡§∞‡§æ‡§∞‡•Ç‡§™ ‡§∏‡§π‡•Ä ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡•§"); } } catch (err) { console.error("JSON ‡§´‡§º‡§æ‡§á‡§≤ ‡§™‡§æ‡§∞‡•ç‡§∏ ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø:", err); alert("JSON ‡§´‡§º‡§æ‡§á‡§≤ ‡§™‡§æ‡§∞‡•ç‡§∏ ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø ‡§π‡•Å‡§à‡•§"); } finally { event.target.value = null; } }; reader.readAsText(file); }
        function clearSavedData() {  if (confirm("‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§µ‡§æ‡§ï‡§à localStorage ‡§Æ‡•á‡§Ç ‡§∏‡•á‡§µ ‡§ï‡§ø‡§è ‡§ó‡§è ‡§∏‡§≠‡•Ä ‡§°‡•á‡§ü‡§æ (‡§π‡§ø‡§∏‡•ç‡§ü‡•ç‡§∞‡•Ä ‡§∏‡§π‡§ø‡§§) ‡§ï‡•ã ‡§π‡§ü‡§æ‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?")) { localStorage.removeItem(STORAGE_KEY_PIECES); localStorage.removeItem(STORAGE_KEY_SETTINGS); localStorage.removeItem(STORAGE_KEY_ID_COUNTER); localStorage.removeItem(STORAGE_KEY_HISTORY);  historyStack = []; alert("localStorage ‡§∏‡•á ‡§∏‡•á‡§µ ‡§ï‡§ø‡§Ø‡§æ ‡§π‡•Å‡§Ü ‡§°‡•á‡§ü‡§æ ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§π‡§ü‡§æ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§"); } }
        function saveStateToHistory() {  const currentState = { pieces: JSON.parse(JSON.stringify(pieces)),  settings: { sheetLength: modalSheetLengthEl.value, sheetWidth: modalSheetWidthEl.value, hasGrain: modalSheetHasGrainEl.checked }, pieceIdCounter: pieceIdCounter, timestamp: new Date().toLocaleTimeString('hi-IN', { hour: 'numeric', minute: '2-digit'}) + ", " + new Date().toLocaleDateString('hi-IN', {day: 'numeric', month: 'short'}) }; if (historyStack.length > 0) { const lastState = historyStack[0]; if (JSON.stringify(lastState.pieces) === JSON.stringify(currentState.pieces) && JSON.stringify(lastState.settings) === JSON.stringify(currentState.settings)) return;  } historyStack.unshift(currentState); if (historyStack.length > MAX_HISTORY_STATES) historyStack.pop();  try { localStorage.setItem(STORAGE_KEY_HISTORY, JSON.stringify(historyStack)); } catch (e) { console.error("‡§π‡§ø‡§∏‡•ç‡§ü‡•ç‡§∞‡•Ä ‡§∏‡•á‡§µ ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø:", e); } }
        function loadHistoryFromStorage() { try { const savedHistory = localStorage.getItem(STORAGE_KEY_HISTORY); historyStack = savedHistory ? JSON.parse(savedHistory) : []; } catch (e) { console.error("‡§π‡§ø‡§∏‡•ç‡§ü‡•ç‡§∞‡•Ä ‡§≤‡•ã‡§° ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø:", e); historyStack = []; } }
        function applyStateFromHistory(historyIndex) { if (historyIndex < 0 || historyIndex >= historyStack.length) return; const stateToLoad = JSON.parse(JSON.stringify(historyStack[historyIndex]));  pieces = stateToLoad.pieces; const settings = stateToLoad.settings; modalSheetLengthEl.value = settings.sheetLength; modalSheetWidthEl.value = settings.sheetWidth; modalSheetHasGrainEl.checked = settings.hasGrain; pieceIdCounter = stateToLoad.pieceIdCounter; renderPiecesTable(); clearPieceInputs();  resultsSummaryEl.textContent = '‡§ï‡•Å‡§≤ ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï ‡§∂‡•Ä‡§ü‡•ç‡§∏: 0'; sheetsContainerEl.innerHTML = '<p style="text-align:center; color: #555;">‡§≤‡•á‡§Ü‡§â‡§ü ‡§¶‡•á‡§ñ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§</p>'; autoSaveData(); closeHistoryModal(); alert(`‡§π‡§ø‡§∏‡•ç‡§ü‡•ç‡§∞‡•Ä ‡§∏‡•á ‡§∏‡•ç‡§•‡§ø‡§§‡§ø ‡§≤‡•ã‡§° ‡§ï‡•Ä ‡§ó‡§à‡•§`); }
        function showHistoryModal() { historyListEl.innerHTML = '';  if (historyStack.length === 0) { const li = document.createElement('li'); li.textContent = "‡§ï‡•ã‡§à ‡§π‡§ø‡§∏‡•ç‡§ü‡•ç‡§∞‡•Ä ‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡•§"; historyListEl.appendChild(li); } else { historyStack.forEach((state, index) => { const li = document.createElement('li'); const displayIndex = historyStack.length - index;  let pieceSummary = state.pieces && state.pieces.length > 0 ? state.pieces.slice(0,2).map(p => p.name).join(', ') + (state.pieces.length > 2 ? '...' : '') : "‡§ï‡•ã‡§à ‡§™‡•Ä‡§∏ ‡§®‡§π‡•Ä‡§Ç"; li.innerHTML = `<span>‡§∏‡•ç‡§•‡§ø‡§§‡§ø #${displayIndex} - ${state.pieces.length} ‡§™‡•Ä‡§∏ (${pieceSummary})</span> <small>${state.timestamp}</small>`; li.onclick = () => applyStateFromHistory(index); historyListEl.appendChild(li); }); } historyModalEl.style.display = 'flex'; }
        function closeHistoryModal() { historyModalEl.style.display = 'none'; }
        window.onload = function() { loadHistoryFromStorage();  const savedPiecesStr = localStorage.getItem(STORAGE_KEY_PIECES); const savedSettingsStr = localStorage.getItem(STORAGE_KEY_SETTINGS); const savedIdCounterStr = localStorage.getItem(STORAGE_KEY_ID_COUNTER); let dataLoadedFromStorage = false; if (savedSettingsStr) {  try { const settings = JSON.parse(savedSettingsStr); modalSheetLengthEl.value = settings.sheetLength || "244"; modalSheetWidthEl.value = settings.sheetWidth || "122"; modalSheetHasGrainEl.checked = typeof settings.hasGrain === 'boolean' ? settings.hasGrain : true; dataLoadedFromStorage = true; } catch(e) { console.error("localStorage ‡§∏‡•á ‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§≤‡•ã‡§° ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø", e); } } else { modalSheetLengthEl.value = "244"; modalSheetWidthEl.value = "122"; modalSheetHasGrainEl.checked = true; } if (savedPiecesStr) { try { pieces = JSON.parse(savedPiecesStr); dataLoadedFromStorage = true; }  catch(e) { console.error("localStorage ‡§∏‡•á ‡§™‡•Ä‡§∏ ‡§≤‡•ã‡§° ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø", e); } } if (savedIdCounterStr) { pieceIdCounter = parseInt(savedIdCounterStr) || 0; } else if (dataLoadedFromStorage && pieces.length > 0){  const maxId = pieces.reduce((max, p) => (typeof p.id === 'number' && p.id > max ? p.id : max), -1); pieceIdCounter = maxId >= 0 ? maxId + 1 : pieces.length; } else { pieceIdCounter = (historyStack.length > 0 && historyStack[0].pieceIdCounter !== undefined) ? historyStack[0].pieceIdCounter : 0;} renderPiecesTable(); clearPieceInputs();  if (dataLoadedFromStorage && pieces.length > 0) { resultsSummaryEl.textContent = '‡§≤‡•á‡§Ü‡§â‡§ü ‡§¨‡§®‡§æ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ó‡§£‡§®‡§æ ‡§ï‡§∞‡•á‡§Ç'; sheetsContainerEl.innerHTML = '<p style="text-align:center; color: #555;">‡§≤‡•á‡§Ü‡§â‡§ü ‡§¶‡•á‡§ñ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§</p>'; } else { resultsSummaryEl.textContent = '‡§ï‡•Å‡§≤ ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï ‡§∂‡•Ä‡§ü‡•ç‡§∏: 0'; sheetsContainerEl.innerHTML = ''; } if (historyStack.length === 0 && !dataLoadedFromStorage) saveStateToHistory(); };
        
        function calculateAndDrawLayout() {
            if (pieces.length === 0) { alert("‡§ó‡§£‡§®‡§æ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡•É‡§™‡§Ø‡§æ ‡§ï‡§Æ ‡§∏‡•á ‡§ï‡§Æ ‡§è‡§ï ‡§™‡•Ä‡§∏ ‡§ú‡•ã‡§°‡§º‡•á‡§Ç‡•§"); return; }
            const sheetL_cm = parseFloat(modalSheetLengthEl.value); 
            const sheetW_cm = parseFloat(modalSheetWidthEl.value);   
            const sheetHasGrain = modalSheetHasGrainEl.checked; 
            if (isNaN(sheetL_cm) || sheetL_cm <= 0 || isNaN(sheetW_cm) || sheetW_cm <= 0) {
                alert("‡§ï‡•É‡§™‡§Ø‡§æ ‡§Æ‡§æ‡§®‡•ç‡§Ø ‡§∂‡•Ä‡§ü ‡§∏‡§æ‡§á‡•õ ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç‡•§"); return;
            }
            let individualPieces = []; let pieceInstanceCounters = {}; 
            pieces.forEach(p_orig => {
                if (!pieceInstanceCounters[p_orig.id]) pieceInstanceCounters[p_orig.id] = 0;
                for (let i = 0; i < p_orig.quantity; i++) {
                    pieceInstanceCounters[p_orig.id]++;
                    individualPieces.push({ ...p_orig, uniqueId: `${p_orig.id}-${pieceInstanceCounters[p_orig.id]}`, 
                        instanceNum: pieceInstanceCounters[p_orig.id], isPlaced: false, x: 0, y: 0, sheetId: 0,
                        placedLength: 0, placedWidth: 0, isRotated: false });
                }
            });
            individualPieces.sort((a, b) => b.area - a.area); 
            let sheetsLayoutData = []; let currentSheetId = 0;
            while (individualPieces.some(p => !p.isPlaced)) {
                currentSheetId++;
                const newSheet = { id: currentSheetId, placedPieces: [], hasGrain: sheetHasGrain, 
                    freeRects: [{ x: 0, y: 0, width: sheetW_cm, height: sheetL_cm, id: `FR-S${currentSheetId}-0` }]};
                sheetsLayoutData.push(newSheet);
                let piecesPlacedOnThisSheetLoop = true;
                while(piecesPlacedOnThisSheetLoop){
                    piecesPlacedOnThisSheetLoop = false;
                    individualPieces.sort((a,b) => a.isPlaced ? 1 : (b.isPlaced ? -1 : b.area - a.area));
                    for (let piece of individualPieces) {
                        if (piece.isPlaced) continue;
                        if (tryPlacePieceOnSheet(piece, newSheet)) { piecesPlacedOnThisSheetLoop = true; break; }
                    }
                }
                 if (newSheet.placedPieces.length === 0 && individualPieces.some(p => !p.isPlaced)) {
                     const unplacedExample = individualPieces.find(p => !p.isPlaced);
                     alert(`‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: ‡§∂‡•Ä‡§ü #${currentSheetId} ‡§™‡§∞ ‡§™‡•Ä‡§∏ "${unplacedExample.name}" (${unplacedExample.width}√ó${unplacedExample.length}) ‡§´‡§ø‡§ü ‡§®‡§π‡•Ä‡§Ç ‡§π‡•Å‡§Ü‡•§`);
                     displayLayout(sheetsLayoutData.filter(s => s.placedPieces.length > 0), sheetL_cm, sheetW_cm); return;
                }
            }
            displayLayout(sheetsLayoutData, sheetL_cm, sheetW_cm);
        }
        
        let freeRectIdCounter_layout = 0; 
        function tryPlacePieceOnSheet(piece, sheet) { // <<<<<<< code-125.html ‡§µ‡§æ‡§≤‡§æ ‡§≤‡•â‡§ú‡§ø‡§ï (KERF ‡§ï‡•á ‡§∏‡§æ‡§•)
            sheet.freeRects.sort((a, b) => (a.width * a.height) - (b.width * b.height) || a.y - b.y || a.x - b.x); 
            let bestFitFound = null; 

            for (let i = 0; i < sheet.freeRects.length; i++) {
                const rect = sheet.freeRects[i];
                
                // ‡§ì‡§∞‡§ø‡§è‡§Ç‡§ü‡•á‡§∂‡§® 1: ‡§∏‡•Ä‡§ß‡§æ (piece.length rect.height ‡§ï‡•á ‡§∏‡§æ‡§•, piece.width rect.width ‡§ï‡•á ‡§∏‡§æ‡§•)
                const requiredW1 = piece.width + KERF_WIDTH_CM;
                const requiredL1 = piece.length + KERF_WIDTH_CM;
                if (piece.length <= rect.height && piece.width <= rect.width) { 
                    if (requiredL1 <= rect.height + KERF_WIDTH_CM*0.1 && requiredW1 <= rect.width + KERF_WIDTH_CM*0.1) {
                        const score = (rect.width * rect.height) - (piece.width * piece.length); // ‡§¨‡§ö‡§æ ‡§π‡•Å‡§Ü ‡§è‡§∞‡§ø‡§Ø‡§æ
                        if (!bestFitFound || score < bestFitFound.score) {
                            bestFitFound = { 
                                rectIndex: i, x: rect.x, y: rect.y,
                                placedLength: piece.length, placedWidth: piece.width, 
                                isRotated: false, score: score 
                            };
                        }
                    }
                }

                // ‡§ì‡§∞‡§ø‡§è‡§Ç‡§ü‡•á‡§∂‡§® 2: ‡§ò‡•Ç‡§Æ‡§æ ‡§π‡•Å‡§Ü (piece.width rect.height ‡§ï‡•á ‡§∏‡§æ‡§•, piece.length rect.width ‡§ï‡•á ‡§∏‡§æ‡§•)
                const requiredW2_rotated = piece.length + KERF_WIDTH_CM; 
                const requiredL2_rotated = piece.width + KERF_WIDTH_CM;  
                if (!sheet.hasGrain && piece.width <= rect.height && piece.length <= rect.width) { 
                    if (requiredL2_rotated <= rect.height + KERF_WIDTH_CM*0.1 && requiredW2_rotated <= rect.width + KERF_WIDTH_CM*0.1) {
                        const score = (rect.width * rect.height) - (piece.length * piece.width);
                         if (!bestFitFound || score < bestFitFound.score) {
                            bestFitFound = { 
                                rectIndex: i, x: rect.x, y: rect.y,
                                placedLength: piece.width, placedWidth: piece.length, 
                                isRotated: true, score: score
                            };
                        }
                    }
                }
            } 
            if (bestFitFound) {
                piece.x = bestFitFound.x; piece.y = bestFitFound.y;
                piece.placedLength = bestFitFound.placedLength; 
                piece.placedWidth = bestFitFound.placedWidth;   
                piece.isRotated = bestFitFound.isRotated; 
                piece.sheetId = sheet.id; piece.isPlaced = true;
                sheet.placedPieces.push({...piece}); 
                splitFreeRect(sheet, bestFitFound.rectIndex, piece); 
                return true;
            }
            return false; 
        }

        function splitFreeRect(sheet, rectIndexBeingUsed, placedPieceDetails) {
            const oldRect = sheet.freeRects.splice(rectIndexBeingUsed, 1)[0]; 
            let newPotentialRects = [];
            const effectivePlacedLength = placedPieceDetails.placedLength + KERF_WIDTH_CM;
            const effectivePlacedWidth = placedPieceDetails.placedWidth + KERF_WIDTH_CM;

            if (oldRect.height - effectivePlacedLength > -KERF_WIDTH_CM*0.5) { 
                newPotentialRects.push({ x: oldRect.x, y: oldRect.y + effectivePlacedLength,
                    width: oldRect.width, height: Math.max(0, oldRect.height - effectivePlacedLength),
                    id: `FR-S${sheet.id}-${++freeRectIdCounter_layout}-B` });
            }
             if (oldRect.width - effectivePlacedWidth > -KERF_WIDTH_CM*0.5) { 
                newPotentialRects.push({ x: oldRect.x + effectivePlacedWidth, y: oldRect.y,
                    width: Math.max(0, oldRect.width - effectivePlacedWidth), height: placedPieceDetails.placedLength, 
                    id: `FR-S${sheet.id}-${++freeRectIdCounter_layout}-R`});
            }
            sheet.freeRects.push(...newPotentialRects.filter(r => r.width > 0.1 && r.height > 0.1));
            optimizeFreeRects(sheet.freeRects, sheet.placedPieces);
        }
        function optimizeFreeRects(freeRects, placedPieces) {
             if (!freeRects || freeRects.length === 0) return;
            let optimizedIteration;
            do {
                optimizedIteration = false;
                for (let i = freeRects.length - 1; i >= 0; i--) {
                    if (!freeRects[i] || freeRects[i].width < 0.1 || freeRects[i].height < 0.1) {
                        if(freeRects[i]) freeRects.splice(i, 1); optimizedIteration = true; continue;
                    }
                    for (let j = freeRects.length - 1; j >= 0; j--) {
                        if (i === j || !freeRects[i] || !freeRects[j]) continue;
                        if (isRectInside(freeRects[i], freeRects[j])) {
                            freeRects.splice(i, 1); optimizedIteration = true; break; 
                        }
                    }
                }
            } while (optimizedIteration);
            freeRects.sort((a, b) => a.y - b.y || a.x - b.x);
        }
        function isRectInside(rectA, rectB) { 
             return rectA.x >= rectB.x && rectA.y >= rectB.y &&
                    rectA.x + rectA.width <= rectB.x + rectB.width &&
                    rectA.y + rectA.height <= rectB.y + rectB.height;
        }
        function rectanglesOverlap(rect1, rect2) {
            const tolerance = 0.01; 
            return !(rect1.x + rect1.width <= rect2.x + tolerance || rect2.x + rect2.width <= rect1.x + tolerance ||
                     rect1.y + rect1.height <= rect2.y + tolerance || rect2.y + rect2.height <= rect1.y + tolerance);
        }
        function getRandomColor() { const h = Math.floor(Math.random() * 360); return `hsla(${h}, 65%, 70%, 0.75)`; }
        let pieceColors = {}; 
        function drawRotatedText(ctx, text, x, y, angleDegrees, font,fillStyle, textAlign = 'center', textBaseline = 'middle') {
            ctx.save(); ctx.textAlign = textAlign; ctx.textBaseline = textBaseline; ctx.font = font; ctx.fillStyle = fillStyle;
            ctx.translate(x, y); ctx.rotate(angleDegrees * Math.PI / 180); ctx.fillText(text, 0, 0); ctx.restore(); 
        }
        function displayLayout(sheets, sheetL_cm, sheetW_cm) {
            resultsSummaryEl.textContent = `‡§ï‡•Å‡§≤ ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï ‡§∂‡•Ä‡§ü‡•ç‡§∏: ${sheets.length}`;
            sheetsContainerEl.innerHTML = ''; pieceColors = {}; freeRectIdCounter_layout = 0;
            const dpr = window.devicePixelRatio || 1;
            sheets.forEach(sheet => {
                if (!sheet) return;
                const wrapper = document.createElement('div'); wrapper.className = 'sheet-wrapper';
                const title = document.createElement('h3');
                title.textContent = `‡§∂‡•Ä‡§ü #${sheet.id} ${sheet.hasGrain ? '(‡§ó‡•ç‡§∞‡•á‡§® ‡§µ‡§æ‡§≤‡•Ä)' : '(‡§¨‡§ø‡§®‡§æ ‡§ó‡•ç‡§∞‡•á‡§®)'}`;
                wrapper.appendChild(title); const canvas = document.createElement('canvas');
                const logicalWidth = sheetW_cm * BASE_CANVAS_SCALE; const logicalHeight = sheetL_cm * BASE_CANVAS_SCALE;
                canvas.width = Math.round(logicalWidth * dpr); canvas.height = Math.round(logicalHeight * dpr);
                canvas.style.width = `${logicalWidth}px`; canvas.style.height = `${logicalHeight}px`;
                wrapper.appendChild(canvas); sheetsContainerEl.appendChild(wrapper);
                const ctx = canvas.getContext('2d'); ctx.scale(dpr, dpr);
                ctx.clearRect(0, 0, logicalWidth, logicalHeight); 
                ctx.strokeStyle = '#bdc3c7'; ctx.lineWidth = 1; 
                ctx.strokeRect(0.5, 0.5, logicalWidth - 1, logicalHeight - 1);
                sheet.placedPieces.forEach(p => { 
                    if (!pieceColors[p.id]) pieceColors[p.id] = getRandomColor();
                    ctx.fillStyle = pieceColors[p.id];
                    const pieceX_logical = p.x * BASE_CANVAS_SCALE; const pieceY_logical = p.y * BASE_CANVAS_SCALE;
                    const pieceWidth_logical = p.placedWidth * BASE_CANVAS_SCALE; const pieceHeight_logical = p.placedLength * BASE_CANVAS_SCALE;
                    ctx.fillRect(pieceX_logical, pieceY_logical, pieceWidth_logical, pieceHeight_logical);
                    ctx.strokeStyle = '#2c3e50'; ctx.lineWidth = 0.5; 
                    ctx.strokeRect(pieceX_logical + 0.5, pieceY_logical + 0.5, pieceWidth_logical - 1, pieceHeight_logical - 1);
                });
                sheet.placedPieces.forEach(p => { 
                    ctx.fillStyle = '#101d2c'; const baseFontSizePt = BASE_CANVAS_SCALE * 3.0; let dynamicFontSize; 
                    const minAllowedLogicalFontSize = 4.0;
                    const pieceX_logical = p.x * BASE_CANVAS_SCALE; const pieceY_logical = p.y * BASE_CANVAS_SCALE;
                    const pieceWidth_logical = p.placedWidth * BASE_CANVAS_SCALE; const pieceHeight_logical = p.placedLength * BASE_CANVAS_SCALE;
                    const canShowAllThreeInside = pieceWidth_logical >= (MIN_TEXT_PIECE_WIDTH_LOGICAL_INSIDE) && pieceHeight_logical >= (MIN_TEXT_PIECE_HEIGHT_LOGICAL_INSIDE * 1.7); 
                    const canShowDimAndInstanceInside = pieceWidth_logical >= (MIN_TEXT_PIECE_WIDTH_LOGICAL_INSIDE * 0.75) && pieceHeight_logical >= (MIN_TEXT_PIECE_HEIGHT_LOGICAL_INSIDE * 1.25);
                    const canShowDimOnlyInside = pieceWidth_logical >= (MIN_TEXT_PIECE_WIDTH_LOGICAL_INSIDE * 0.55) && pieceHeight_logical >= (MIN_TEXT_PIECE_HEIGHT_LOGICAL_INSIDE * 0.55);
                    const canShowDimVerticalInside = pieceWidth_logical < (MIN_TEXT_PIECE_WIDTH_LOGICAL_INSIDE * 0.55) && pieceHeight_logical >= (MIN_TEXT_PIECE_HEIGHT_LOGICAL_INSIDE * 1.4) && pieceWidth_logical >= (minAllowedLogicalFontSize * 1.8);
                    const text1_name = `${p.name}`; const text2_dim = `${p.width.toFixed(0)}√ó${p.length.toFixed(0)}${p.isRotated ? '(R)' : ''}`; // ‡§ö‡•å‡§°‡§º‡§æ‡§à √ó ‡§≤‡§Ç‡§¨‡§æ‡§à
                    const text3_instance = `#${p.instanceNum}`;
                    let textX, textY; let textAlign = 'center'; let textBaseline = 'middle';
                    let leaderLine = null; let textAngle = 0; let fontStyle; let currentFontSize;
                    if (canShowAllThreeInside) {
                        const maxChars = Math.max(p.name.length, text2_dim.length, text3_instance.length, 3);
                        dynamicFontSize = Math.min(baseFontSizePt, pieceHeight_logical / 5, pieceWidth_logical / (maxChars * 0.62) ); 
                        currentFontSize = Math.max(minAllowedLogicalFontSize, Math.round(dynamicFontSize)); fontStyle = `bold ${currentFontSize}px Arial`; 
                        textX = pieceX_logical + pieceWidth_logical / 2; const lineHeight = currentFontSize * 1.3; 
                        drawRotatedText(ctx, text1_name, textX, pieceY_logical + pieceHeight_logical / 2 - lineHeight, 0, fontStyle, ctx.fillStyle);
                        drawRotatedText(ctx, text2_dim,  textX, pieceY_logical + pieceHeight_logical / 2, 0, fontStyle, ctx.fillStyle);
                        drawRotatedText(ctx, text3_instance,textX, pieceY_logical + pieceHeight_logical / 2 + lineHeight, 0, fontStyle, ctx.fillStyle);
                    } else if (canShowDimAndInstanceInside) { 
                        const maxChars = Math.max(text2_dim.length, text3_instance.length, 3);
                        dynamicFontSize = Math.min(baseFontSizePt * 1.05, pieceHeight_logical / 3, pieceWidth_logical / (maxChars * 0.58) );
                        currentFontSize = Math.max(minAllowedLogicalFontSize, Math.round(dynamicFontSize)); fontStyle = `bold ${currentFontSize}px Arial`;
                        textX = pieceX_logical + pieceWidth_logical / 2; const lineHeight = currentFontSize * 0.8;
                        drawRotatedText(ctx, text2_dim,  textX, pieceY_logical + pieceHeight_logical / 2 - lineHeight, 0, fontStyle, ctx.fillStyle);
                        drawRotatedText(ctx, text3_instance,textX, pieceY_logical + pieceHeight_logical / 2 + lineHeight, 0, fontStyle, ctx.fillStyle);
                    } else if (canShowDimOnlyInside) { 
                        dynamicFontSize = Math.min(baseFontSizePt * 1.15, pieceHeight_logical / 2.2, pieceWidth_logical / (text2_dim.length * 0.58) );
                        currentFontSize = Math.max(minAllowedLogicalFontSize, Math.round(dynamicFontSize)); fontStyle = `bold ${currentFontSize}px Arial`;
                        textX = pieceX_logical + pieceWidth_logical / 2;
                        drawRotatedText(ctx, text2_dim, textX, pieceY_logical + pieceHeight_logical / 2, 0, fontStyle, ctx.fillStyle);
                    } else if (canShowDimVerticalInside) { 
                        dynamicFontSize = Math.min(baseFontSizePt * 0.95, pieceWidth_logical / 2.0, pieceHeight_logical / (text2_dim.length * 0.58) ); 
                        currentFontSize = Math.max(minAllowedLogicalFontSize, Math.round(dynamicFontSize)); fontStyle = `bold ${currentFontSize}px Arial`;
                        textX = pieceX_logical + pieceWidth_logical / 2; textY = pieceY_logical + pieceHeight_logical / 2; 
                        textAngle = -90; drawRotatedText(ctx, text2_dim, textX, textY, textAngle, fontStyle, ctx.fillStyle);
                    } else { 
                        const combinedTextOutside = `${text2_dim} ${text3_instance}`; 
                        currentFontSize = Math.round(baseFontSizePt * 0.75); currentFontSize = Math.max(minAllowedLogicalFontSize, currentFontSize);
                        fontStyle = `bold ${currentFontSize}px Arial`; ctx.font = fontStyle; 
                        const metrics = ctx.measureText(combinedTextOutside); const textWidthMeasured = metrics.width;
                        const textHeightEstimated = currentFontSize; const gap = 3; textAngle = 0; let foundSpotOutside = false;
                        if (pieceY_logical - textHeightEstimated - gap*2 > 0) { textX = pieceX_logical + pieceWidth_logical / 2; textY = pieceY_logical - gap - textHeightEstimated / 2; textAlign = 'center'; textBaseline = 'middle'; leaderLine = {startX: textX, startY: pieceY_logical, endX: textX, endY: textY + textHeightEstimated/2 +1}; foundSpotOutside = true;
                        } else if (!foundSpotOutside && pieceY_logical + pieceHeight_logical + textHeightEstimated + gap * 2 < logicalHeight) { textX = pieceX_logical + pieceWidth_logical / 2; textY = pieceY_logical + pieceHeight_logical + gap + textHeightEstimated / 2; textAlign = 'center'; textBaseline = 'middle'; leaderLine = {startX: textX, startY: pieceY_logical + pieceHeight_logical, endX: textX,endY: textY - textHeightEstimated / 2 - 1}; foundSpotOutside = true;
                        } else if (!foundSpotOutside && pieceX_logical + pieceWidth_logical + textWidthMeasured + gap * 2 < logicalWidth) { textX = pieceX_logical + pieceWidth_logical + gap; textY = pieceY_logical + pieceHeight_logical / 2; textAlign = 'left'; textBaseline = 'middle'; leaderLine = {startX: pieceX_logical + pieceWidth_logical, startY: textY, endX: textX - 1, endY: textY }; foundSpotOutside = true;
                        } else if (!foundSpotOutside && pieceX_logical - textWidthMeasured - gap * 2 > 0) { textX = pieceX_logical - gap - textWidthMeasured; textY = pieceY_logical + pieceHeight_logical / 2; textAlign = 'left'; textBaseline = 'middle'; leaderLine = {startX: pieceX_logical, startY: textY, endX: textX + textWidthMeasured + 1, endY: textY}; foundSpotOutside = true;
                        } else { currentFontSize = 0; }
                        if (currentFontSize > 0 && foundSpotOutside) {
                            drawRotatedText(ctx, combinedTextOutside, textX, textY, 0, fontStyle, ctx.fillStyle, textAlign, textBaseline);
                            if (leaderLine) { ctx.beginPath(); ctx.moveTo(leaderLine.startX, leaderLine.startY); ctx.lineTo(leaderLine.endX, leaderLine.endY); ctx.strokeStyle = '#333'; ctx.lineWidth = 0.4; ctx.stroke(); }
                        }
                    }
                });
                ctx.strokeStyle = 'rgba(52, 152, 219, 0.5)'; ctx.lineWidth = 0.3; 
                sheet.freeRects.forEach(rect => { 
                    if (rect.width > 0.5 && rect.height > 0.5) { 
                        const rectX_logical = rect.x * BASE_CANVAS_SCALE; const rectY_logical = rect.y * BASE_CANVAS_SCALE;
                        const rectWidth_logical = rect.width * BASE_CANVAS_SCALE; const rectHeight_logical = rect.height * BASE_CANVAS_SCALE; 
                        ctx.strokeRect(rectX_logical + 0.5, rectY_logical + 0.5, rectWidth_logical - 1, rectHeight_logical - 1);
                        if (rectWidth_logical >= MIN_TEXT_FREE_WIDTH_LOGICAL && rectHeight_logical >= MIN_TEXT_FREE_HEIGHT_LOGICAL) {
                            ctx.fillStyle = 'rgba(41, 128, 185, 0.7)'; const baseFontSizePt = 5.5; 
                            let dynamicFontSize = Math.min(baseFontSizePt, rectHeight_logical / 3, rectWidth_logical / 5 );
                            dynamicFontSize = Math.max(baseFontSizePt * 0.5, dynamicFontSize); ctx.font = `${Math.round(dynamicFontSize)}px Arial`;
                            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                            const text = `${rect.width.toFixed(0)}√ó${rect.height.toFixed(0)}`; // ‡§ö‡•å‡§°‡§º‡§æ‡§à √ó ‡§≤‡§Ç‡§¨‡§æ‡§à 
                            ctx.fillText(text, rectX_logical + rectWidth_logical / 2, rectY_logical + rectHeight_logical / 2);
                        }
                    }
                });
            });
        }
        function prepareForPrint() {
            if (sheetsContainerEl.innerHTML === '' || sheetsContainerEl.textContent.includes("‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡•á‡§Ç")) {
                alert("‡§™‡•ç‡§∞‡§ø‡§Ç‡§ü ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§™‡§π‡§≤‡•á ‡§≤‡•á‡§Ü‡§â‡§ü ‡§ï‡•Ä ‡§ó‡§£‡§®‡§æ ‡§ï‡§∞‡•á‡§Ç‡•§"); return;
            }
            window.print();
        }
        
        clearPieceInputs(); 
        renderPiecesTable();

    </script>
</body>
</html>
